#include "NGCInterList.h"
#include <iostream>
#include <stdio.h>

NGC_INTERP_LIST interp_list; /* NML Union, for interpreter */

// sets the line number used for subsequent appends
void NGC_INTERP_LIST::set_line_number(int line)
{
    next_line_number = line;
}

int NGC_INTERP_LIST::append(std::unique_ptr<NMLmsg>&& ngc_msg_ptr)
{
    /* check for invalid data */
    if (NULL == ngc_msg_ptr) {
        printf("NML_INTERP_LIST::append : attempt to append NULL msg\n");
        return -1;
    }

    NGC_INTERP_LIST_NODE node {next_line_number, std::move(ngc_msg_ptr)};

    // stick it on the list
    linked_list.emplace_back(std::move(node));

    std::cout << ((int)linked_list.size()) << std::endl;

    printf("%d\n", ((int)linked_list.size()));

    return 0;
}

std::unique_ptr<NMLmsg> NGC_INTERP_LIST::get()
{
    if (linked_list.empty()) {
        line_number = 0;
        return NULL;
    }

    // get it off the front
    auto node = std::move(linked_list.front());
    linked_list.pop_front();

    // save line number of this one, for use by get_line_number
    line_number = node.line_number;

    return std::move(node.command);
}

void NGC_INTERP_LIST::clear()
{
    linked_list.clear();
}

void NGC_INTERP_LIST::print()
{
    printf("NML_INTERP_LIST::print(): list size=%lu\n", linked_list.size());
    for (auto& i : linked_list) {
        auto& msg = *(i.command);
        printf("--> type=%s,  line_number=%d\n", emc_symbol_lookup(msg._type), i.line_number);
    }
    printf("\n");
}

int NGC_INTERP_LIST::len()
{
    return ((int)linked_list.size());
}

int NGC_INTERP_LIST::get_line_number()
{
    return line_number;
}


